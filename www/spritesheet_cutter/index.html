<html lang="en">
  <head>
    <meta charset="utf-8" />

    <meta
      name="description"
      content="Wojtek (Wojciech) Pachowiak's own webpage!"
    />
    <title>Wojtek Pachowiak</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0 user-scalable=0"
    />

    <link rel="icon" type="image/x-icon" href="../resources/icons/asuka.ico" />

    <link rel="stylesheet" href="../index.css" />
  </head>

  <body>
    <script src="main.js" type="module"></script>

    <!-- split in two panes -->
    <div class="flex flex-row h-screen overflow-x-hidden items-center">
      <!-- area for dropping files to -->
      <div class="w-4/5 h-full bg-gray-200" id="leftPane">
        <!-- before uploading a file -->
        <div
          class="flex flex-col h-full items-center justify-center"
          id="spritesheetCanvasBeforeUpload"
        >
          <div class="flex flex-col items-center justify-center">
            <p class="text-2xl font-bold">Drop your spritesheet here</p>
            <p class="text-sm">or click to select</p>
            <input
              type="file"
              id="filePicker"
              name="filePicker"
              class="hidden"
            />
            <label
              for="filePicker"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
              >Select file</label
            >
          </div>
        </div>

        <!-- after uploading a file -->
        <div
          class="flex flex-col h-full items-center justify-center hidden"
          id="spritesheetCanvasAfterUpload"
        >
          <div class="flex flex-col items-center justify-center">
          <canvas id="spritesheetCanvas" class="absolute " style="image-rendering: pixelated;"></canvas>
          </div>
        </div>
      </div>

      <!-- right bar for setting -->
      <div class="w-1/5 h-full bg-gray-300" id="rightPane">
        <div class="flex flex-col h-full items-center justify-center">
          <div class="flex flex-col items-center justify-center">
            <!-- zoom in zoom out spritesheet -->
            <button
              id="zoomIn"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
            >
              Zoom in
            </button>
            <button
              id="zoomOut"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
            >
              Zoom out
            </button>

            <!-- remove spritesheet -->
            <button
              id="removeSpritesheet"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
            >
              Remove spritesheet
            </button>

            <!-- Calculate bounds -->
            <button
              id="calculateBounds"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
            >
              Calculate bounds
            </button>

            <button
              id="tightPacking"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
            >
              Tight packing
            </button>
            <button
              id="parseableCoordinates"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
            >
              Parseable coordinates
            </button>
            <button
              id="seperateImages"
              class="bg-blue-500 text-white p-2 rounded-lg cursor-pointer"
            >
              Separate images
            </button>
            <!-- eyedropper -->
            <div class="flex flex-row items-center justify-center">
              <label for="colorPicker">Background color: </label>

              <input type="color" id="colorPicker" name="colorPicker" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
import JSZip from "jszip"
      const globals = {
          SPRITESHEET_WIDTH: null,
          SPRITESHEET_HEIGHT: null,
          ZOOM_SPEED: 1.1,
          SPRITESHEET_DRAG_OFFSET: { x: 0, y: 0 },
          SPRITESHEET_LEFTTOP_OFFSET: { x: 0, y: 0 },
          DOMINANT_COLOR: null,
          MOUSE_POS: { x: 0, y: 0 },
          BOUDING_BOXES: []
      }

      // on file drop event or select file hide "spritesheetCanvasBeforeUpload" and show "spritesheetCanvasAfterUpload"\
      const leftPane = document.getElementById('leftPane');
      const spritesheetCanvasBeforeUpload = document.getElementById('spritesheetCanvasBeforeUpload');
      const spritesheetCanvasAfterUpload = document.getElementById('spritesheetCanvasAfterUpload');
      const filePicker = document.getElementById('filePicker');
      const spritesheetCanvas = document.getElementById('spritesheetCanvas');
      const ctx = spritesheetCanvas.getContext('2d', { antialias: false, willReadFrequently: true });

      // const frameWidth = document.getElementById('frameWidth');
      // const frameHeight = document.getElementById('frameHeight');
      // const padding = document.getElementById('padding');
      // const outputFormat = document.getElementById('outputFormat');
      // const outputQuality = document.getElementById('outputQuality');
      // const outputName = document.getElementById('outputName');
      // const cut = document.getElementById('cut');

      function getDominantColor(imageMatrix) {
          const colorCounts = {};
          for (let i = 0; i < imageMatrix.data.length; i += 4) {
              const color = `#${imageMatrix.data[i].toString(16).padStart(2, '0')}${imageMatrix.data[i + 1].toString(16).padStart(2, '0')}${imageMatrix.data[i + 2].toString(16).padStart(2, '0')}`;
              if (colorCounts[color]) {
                  colorCounts[color]++;
              } else {
                  colorCounts[color] = 1;
              }
          }
          let maxCount = 0;
          let dominantColor = null;
          for (const color in colorCounts) {
              if (colorCounts[color] > maxCount) {
                  maxCount = colorCounts[color];
                  dominantColor = color;
              }
          }
          return dominantColor;
      }

      function readFile(file) {
          const reader = new FileReader();
          reader.onload = (e) => {
              const img = new Image();
              img.onload = () => {
                  spritesheetCanvas.width = img.width;
                  spritesheetCanvas.height = img.height;
                  globals.SPRITESHEET_WIDTH = img.width;
                globals.SPRITESHEET_HEIGHT = img.height;
                globals.SPRITESHEET_LEFTTOP_OFFSET = { x: img.width / 2, y: img.height / 2 };
                // remove styles from previous image
                spritesheetCanvas.style.width = ``;
                spritesheetCanvas.style.left = ``;
                spritesheetCanvas.style.top = ``;
                
                
                ctx.drawImage(img, 0, 0);
                //draw red on center
                ctx.strokeStyle = 'red';
                ctx.strokeRect(img.width / 2 - 1, img.height / 2 - 1, 2, 2);

                globals.DOMINANT_COLOR = getDominantColor(ctx.getImageData(0, 0, img.width, img.height));
                // update color picker
                document.getElementById('colorPicker').value = globals.DOMINANT_COLOR;
              }
              img.src = e.target.result;
          }
          reader.readAsDataURL(file);
      }

      filePicker.addEventListener('change', (e) => {
          const file = e.target.files[0];
          readFile(file);

          spritesheetCanvasBeforeUpload.classList.add('hidden');
          spritesheetCanvasAfterUpload.classList.remove('hidden');
      });

      spritesheetCanvas.addEventListener('dragover', (e) => {
          e.preventDefault();
      });

      spritesheetCanvas.addEventListener('drop', (e) => {
          e.preventDefault();
          const file = e.dataTransfer.files[0];
          readFile(file);
          spritesheetCanvasBeforeUpload.classList.add('hidden');
          spritesheetCanvasAfterUpload.classList.remove('hidden');
      });

    //   on mouse drag event move the canvas
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        spritesheetCanvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            globals.SPRITESHEET_DRAG_OFFSET = { x: spritesheetCanvas.style.width/2, y: spritesheetCanvas.style.height /2};
        });

        document.addEventListener('mouseup', (e) => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                // edit tailwind translate styleclass
                // spritesheetCanvas.className = `translate-x-${dx} translate-y-${dy}`;
                globals.SPRITESHEET_LEFTTOP_OFFSET = { x: e.clientX , y: e.clientY };
                spritesheetCanvas.style.left = `${globals.SPRITESHEET_LEFTTOP_OFFSET.x - globals.SPRITESHEET_WIDTH / 2}px`;
                spritesheetCanvas.style.top = `${globals.SPRITESHEET_LEFTTOP_OFFSET.y - globals.SPRITESHEET_HEIGHT / 2}px`;
            }
        });


        //get mouse pos
        document.addEventListener('mousemove', (e) => {
            globals.MOUSE_POS = { x: e.clientX, y:  e.clientY };
            //console.log("mouse",globals.MOUSE_POS);
        });


        function zoomInView() {
            globals.SPRITESHEET_WIDTH /= globals.ZOOM_SPEED;
            globals.SPRITESHEET_HEIGHT /= globals.ZOOM_SPEED;
            spritesheetCanvas.style.width = `${globals.SPRITESHEET_WIDTH}px`;

            const mousePosWithinCanvas = {
                x: globals.MOUSE_POS.x - globals.SPRITESHEET_LEFTTOP_OFFSET.x,
                y: globals.MOUSE_POS.y - globals.SPRITESHEET_LEFTTOP_OFFSET.y
            }
            console.log("mousePos",globals.MOUSE_POS);
            console.log("globals.SPRITESHEET_LEFTTOP_OFFSET",globals.SPRITESHEET_LEFTTOP_OFFSET);
            console.log("mouseSubtract",mousePosWithinCanvas);
            console.log("wh",globals.SPRITESHEET_WIDTH/2, globals.SPRITESHEET_HEIGHT/2);

            spritesheetCanvas.style.left = `${globals.SPRITESHEET_LEFTTOP_OFFSET.x + mousePosWithinCanvas.x - globals.SPRITESHEET_WIDTH/2}px`;
            spritesheetCanvas.style.top = `${globals.SPRITESHEET_LEFTTOP_OFFSET.y + mousePosWithinCanvas.y - globals.SPRITESHEET_HEIGHT/2}px`;
        }

        function zoomOutView() {
            globals.SPRITESHEET_WIDTH *= globals.ZOOM_SPEED;
            globals.SPRITESHEET_HEIGHT *= globals.ZOOM_SPEED;
            spritesheetCanvas.style.width = `${globals.SPRITESHEET_WIDTH}px`;
            spritesheetCanvas.style.left = `${globals.SPRITESHEET_LEFTTOP_OFFSET.x - globals.SPRITESHEET_WIDTH / 2}px`;
            spritesheetCanvas.style.top = `${globals.SPRITESHEET_LEFTTOP_OFFSET.y - globals.SPRITESHEET_HEIGHT / 2}px`;
        }




      // zoom in zoom out spritesheet
      const zoomIn = document.getElementById('zoomIn');
      const zoomOut = document.getElementById('zoomOut');
      zoomIn.addEventListener('click', (e) => {
          zoomInView();


      });

      zoomOut.addEventListener('click', (e) => {
         zoomOutView();
        });

    // on mouse scroll also zoom
    spritesheetCanvas.addEventListener('wheel', (e) => {
        if (e.deltaY < 0) {
            zoomInView();
        } else {
            zoomOutView();
        }
    });

      // remove spritesheet
      const removeSpritesheet = document.getElementById('removeSpritesheet');
      removeSpritesheet.addEventListener('click', (e) => {
          ctx.clearRect(0, 0, spritesheetCanvas.width, spritesheetCanvas.height);
          spritesheetCanvasBeforeUpload.classList.remove('hidden');
          spritesheetCanvasAfterUpload.classList.add('hidden');
      });

      // tight packing
      const tightPacking = document.getElementById('tightPacking');
      tightPacking.addEventListener('click', (e) => {
          console.log('tightPacking');
      });


      function downloadJSON(data, filename) {
          const blob = new Blob([data], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
      }

      // parseable coordinates
      const parseableCoordinates = document.getElementById('parseableCoordinates');
      parseableCoordinates.addEventListener('click', (e) => {
          // download a .json file with the coordinates of the sprites
            const data = JSON.stringify(globals.BOUDING_BOXES);
            downloadJSON(data, 'sprites.json');

      });



        

      // seperate images
      const seperateImages = document.getElementById('seperateImages');
      seperateImages.addEventListener('click', (e) => {
        //extract images from bounding boxes and download them as a zip
        const images = [];
        globals.BOUDING_BOXES.forEach((bound, index) => {
            const image = ctx.getImageData(bound.left, bound.top, bound.right - bound.left, bound.bottom - bound.top);
            const tmpcanvas = document.createElement('canvas');
            tmpcanvas.width = bound.right - bound.left;
            tmpcanvas.height = bound.bottom - bound.top;
            const tmpctx = tmpcanvas.getContext('2d');
            tmpctx.putImageData(image, 0, 0);
            images.push(tmpcanvas.toDataURL('image/png'));
            console.log("images",images);
        });
        //download as zip
        const zip = new JSZip();
        images.forEach((image, index) => {
            zip.file(`image${index}.png`, image.split('base64,')[1], { base64: true });
        });
        zip.generateAsync({ type: 'blob' }).then((content) => {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = 'sprites.zip';
            a.click();
        });
        
      });

      // calculate bounds
      const calculateBounds = document.getElementById('calculateBounds');
      calculateBounds.addEventListener('click', (e) => {
          let backgroundColor = document.getElementById('colorPicker').value;
            backgroundColor = [
                parseInt(backgroundColor.slice(1, 3), 16),
                parseInt(backgroundColor.slice(3, 5), 16),
                parseInt(backgroundColor.slice(5, 7), 16)
            ];
          const imageMatrix = ctx.getImageData(0, 0, spritesheetCanvas.width, spritesheetCanvas.height);

          function getBounds(imageMatrix, backgroundColor){
              // an array of tuples (bottomLeft, topRight) identifying the bounds of each sprite
              const bounds = []

              // a fixed-size array of booleans to keep track of which pixels have been visited
              const visited = new Array(imageMatrix.data.length / 4).fill(false);

              // Algorithm:
              // 1. Iterate over the imageMatrix.data and find the first non-background pixel
              // 2. From this pixel, perform a flood fill (using a queue) to find the bounds of the sprite
              //    - keep track of the min and max x and y values of the pixels in the sprite
              //    - keep track of the pixels that have been visited
              // 3. when finished add these bounds to the bounds array
              // 4. repeat until all sprites are found

                for (let i = 0; i < imageMatrix.data.length; i += 4) {

                    const checkBackground = (i) => {
                        const epsilon = 30;
                        return (
                            Math.abs(imageMatrix.data[i] - backgroundColor[0]) < epsilon &&
                            Math.abs(imageMatrix.data[i + 1] - backgroundColor[1]) < epsilon &&
                            Math.abs(imageMatrix.data[i + 2] - backgroundColor[2]) < epsilon
                        );
                    }
                    
                  if (checkBackground(i) || visited[i / 4]) {
                      continue;
                  }
                  
                    const queue = [i / 4];
                    let minx = Infinity;
                    let miny = Infinity;
                    let maxx = -Infinity;
                    let maxy = -Infinity;
                    
                    

                    while (queue.length > 0) {

                        const index = queue.shift();
                         if (visited[index]) {
                             continue;
                         }
                        visited[index] = true;
                        const x = index % imageMatrix.width;
                        const y = Math.floor(index / imageMatrix.width);
                        minx = Math.min(minx, x);
                        miny = Math.min(miny, y);
                        maxx = Math.max(maxx, x);
                        maxy = Math.max(maxy, y);
                        if (x > 0 && !visited[index - 1] && !checkBackground((index - 1) * 4)) {
                            queue.push(index - 1);
                        }
                        if (x < imageMatrix.width - 1 && !visited[index + 1] && !checkBackground((index + 1)* 4)) {
                            queue.push(index + 1);
                        }
                        if (y > 0 && !visited[index - imageMatrix.width] && !checkBackground((index - imageMatrix.width)*4)) {
                            queue.push(index - imageMatrix.width);
                        }
                        if (y < imageMatrix.height - 1 && !visited[index + imageMatrix.width] && !checkBackground((index + imageMatrix.width)*4)) {
                            queue.push(index + imageMatrix.width);
                        }

                        
                    }
                    bounds.push({ left: minx, top: miny, right: maxx, bottom: maxy });
              }
              // draw these bounds on the canvas
                ctx.strokeStyle = 'red';
                bounds.map((bound) => {
                    ctx.strokeRect(bound.left, bound.top, bound.right - bound.left, bound.bottom - bound.top);
                });
              return bounds;
          }

          globals.BOUDING_BOXES = getBounds(imageMatrix, backgroundColor);



      });
    </script>
  </body>
</html>
